'''
BFSで迷路の最短経路長を求める。
移動コストは全て1とする。
キューには collections.deque を使用。
'''

from collections import deque


def bfs(x, y):
    INF = float('inf')
    L = [[INF]*W for _ in range(H)]         #スタート位置から各マスへの経路長(INFは未探索)
    L[sy][sx] = 0
    Q = deque([[sx, sy]])
    while len(Q)!=0:
        x, y = Q.popleft()
        if x==gx and y==gy:
            break
        for i in range(4):
            nx, ny = x + [1,0,-1,0][i], y + [0,1,0,-1][i]
            if 0<=nx and nx<W and 0<=ny and ny<H:
                if M[ny][nx]=='.' and L[ny][nx]==INF:
                    Q.append([nx, ny])
                    L[ny][nx] = L[y][x] + 1
    return L[gy][gx]


H, W = 10, 10           #迷路の大きさ
M = [
    ['#', 'S', '#', '#', '#', '#', '#', '#', '.', '#'],
    ['.', '.', '.', '.', '.', '.', '#', '.', '.', '#'],
    ['.', '#', '.', '#', '#', '.', '#', '#', '.', '#'],
    ['.', '#', '.', '.', '.', '.', '.', '.', '.', '.'],
    ['#', '#', '.', '#', '#', '.', '#', '#', '#', '#'],
    ['.', '.', '.', '.', '#', '.', '.', '.', '.', '#'],
    ['.', '#', '#', '#', '#', '#', '#', '#', '.', '#'],
    ['.', '.', '.', '.', '#', '.', '.', '.', '.', '.'],
    ['.', '#', '#', '#', '#', '.', '#', '#', '#', '.'],
    ['.', '.', '.', '.', '#', '.', '.', '.', 'G', '#'],
    ]

sx, sy = 1, 0           #スタートの座標
gx, gy = 9, 8           #ゴールの座標
print(bfs(sx, sy))      #スタートからゴールまでの最短経路